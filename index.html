<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>title</title>

    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.4/lodash.min.js"></script>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    
    <script src="data.js"></script>
   
    <style type="text/css">

        body {
            padding: 20px
        }

        div { 
            margin: 20px;
            padding: 20px;
            border: solid
        }

        .original {
            color: black
        }

        .new {
            color: red
        }

        .removed {
            color: grey;
            text-decoration: line-through;
        }

        .accepted {
            color: blue
        }
        
    </style>

</head>
  
  <body>
  
    <button id="modify">modify</button>
    <button id="append">append</button>
    <button id="undo">undo</button>
    <button id="redo">redo</button>
    <select id="replace_insert">
        <option value="replace">replace</option>
        <option value="insert-retain">insert (retain)</option>
        <option value="insert">insert</option>
    </select> 
    
    <button id="finish">finish</button>
    
    <span>initialize with:</span>
    <button id="nothing">nothing</button>
    <button id="sonnet">sonnet</button>
    
    
    <div id="current_text"></div>

    <script>

        var undo_states = []
        var redo_states = []

        var state = { current_words: [],
                      fragment_range: null,
                      append_index: 0,
                    }

        var options = {
            mode: "replace",
            fragment_length_range: [5,7],
            main_sonnet: 1
        } 

        function get_outside_occurences (word) {
            // searches all _other_ sonnets for a word
            // format for results is an array [ <sonnet index>, <word_index> ]
            
            var others = _.without(sonnets, sonnets[options.main_sonnet])
            result = []
            others.forEach( (s,si) => {
                s.forEach( (w,wi) => {
                    if (word == w) result.push([sonnets.indexOf(s), wi])
                })
            })

            
            return result
        }

        function get_fragment(location, length) {
            var sonn = sonnets[location[0]]
            
            return sonn.slice(location[1], location[1] + length)    
        }

        function get_random_fragment (word) {
            var occurences = get_outside_occurences (word)
            if (occurences.length == 0) return null
            return get_fragment( _.sample( occurences ), _.random(...options.fragment_length_range))
        }

        function replace_n_at(fragment, index, n) {
            var removed = state.current_words.splice(index, n, ...fragment)
            removed = removed.slice().map( word => { return { word: word.word, status: "removed" }})
            state.current_words.splice(index, 0, ...removed)
        }

        function replace_at(fragment, index) {
            replace_n_at(fragment, index, fragment.length)
        }

        function insert_at (fragment, index, retain) {
            replace_n_at(fragment, index, (retain) ? 0 : 1)
        }   

        function accept() {
            state.current_words.forEach(word => { if (word.status == "new") word.status = "accepted" })
            state.current_words = state.current_words.filter(word => word.status != "removed")
        }

        function modify() {
            accept()
            
            var fragment = null, spot
            while (!fragment) {
                spot = _.random(0, state.current_words.length - 1)
                fragment = get_random_fragment( state.current_words[spot].word )
            }

            fragment = fragment.map(word => { return { word, status: "new" }})
    
            switch(options.mode) {
                case "replace" : 
                replace_at(fragment, spot)
                break

                case "insert-retain" :
                insert_at(fragment, spot, true)
                break

                case "insert" :
                insert_at(fragment, spot, false)
            }

            state.fragment_range = [spot, spot + fragment.length - 1]   
        }

        function append() {
            action_wrapper(() => {

                accept()

                var found = null
                var count = 0
                var num_matches = 0
                var nth_match = _.random(1,4)
                while (!found) {
                    var word = sonnets[options.main_sonnet][state.append_index]
                    state.current_words.push({ word, status: "original"})

                    count++
                    state.append_index++
                    if (state.append_index >= sonnets[options.main_sonnet].length) state.append_index = 0
                    
                    if (count >= options.fragment_length_range[0]) {
                        occs = get_outside_occurences(word)
                        if (occs.length > 0) {
                            num_matches++
                            if (num_matches == nth_match) {
                                found = get_fragment(_.sample(occs), _.random(...options.fragment_length_range))
                                console.log(found)
                            }
                        }
                    }
                }
                
                found = found.map(word => { return { word, status: "new" } })

                replace_n_at(found, state.current_words.length - 1, (options.mode != "insert-retain"))
            })
        }


        function finish() {
            state.current_words = 
            state.current_words
            .filter(word => word.status != "removed")

            state.current_words
            .forEach( word => { if (word.status == "new") word.status = "accepted" })
        }

        function render() {

            var words = state.current_words.map( (word, i) => 
                '<span class="' + word.status + '">' + word.word + '</span>')
            $("#current_text").html(_.chunk(words, 10).map(line => line.join(" ") + "<br>")) 
        }

        function undo() {
            if (undo_states.length > 0) {
                redo_states.push(state)
                state = undo_states.pop()
                render(state)
            }
        }

        function redo() {
            if (redo_states.length > 0) {
                undo_states.push(_.cloneDeep(state))
                state = redo_states.pop()
                render(state)
            }
        }

        function action_wrapper(fn) {
            undo_states.push(_.cloneDeep(state))
            redo_states = []
            fn.call(null)
            render(state)
        }   

        

        function clear() {
            action_wrapper(() => {
                state.current_words = []
                state.append_index = 0
            })
        }

        function init_with_fragment() {
            action_wrapper(() => {
                var opening = sonnets[options.main_sonnet].slice(0, _.random(...options.fragment_length_range))
                state.current_words = opening.map(word => { return { word, status: "original" } })
            })
        }

        function init_with_sonnet() {
            action_wrapper(() => {
                state.current_words = sonnets[options.main_sonnet].map(word => { return { word, status: "original"} } )
            })
        }

        $("#modify").click(function() {
            undo_states.push(_.cloneDeep(state))
            modify()
            render(state)
        })

        $("#append").click(append)


        $("#finish").click(function() {
            undo_states.push(_.cloneDeep(state))
            finish()
            render(state)
        })

        $("#undo").click(undo)
        $("#redo").click(redo)

        $("#replace_insert").change( (e) => {
            options.mode = $(e.target).val()
        })

        $("#nothing").click(clear)
        $("#sonnet").click(init_with_sonnet)

        init_with_sonnet()
        undo_states = []
        render()

    </script>

  </body>
</html>